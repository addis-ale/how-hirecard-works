# Supabase Auth Lock Fix

## The Problem

Supabase's `@supabase/auth-js` (GoTrueClient) uses the `navigator.locks` Web API to coordinate authentication operations across browser tabs. **The implementation has a critical bug: locks are acquired with infinite timeouts** (`acquireTimeout: -1`), meaning if a lock is never properly released, all other tabs wait forever.

### How it manifests

- Open multiple tabs (4-10) of your app
- Perform login/logout in one tab
- Other tabs become **permanently broken** - auth operations hang indefinitely
- Errors: `"timeout acquiring lock"`, `"auth/session lock"`
- Especially bad on **Chrome Android** and when tabs are left open overnight

### Root cause (in Supabase's code)

```typescript
// GoTrueClient.ts - line 672
async signInWithPassword(credentials) {
  return this._acquireLock(-1, async () => {  // -1 = INFINITE timeout!
    return await this._signInWithPassword(credentials)
  })
}
```

All auth methods (`signIn`, `signOut`, `refreshSession`, `getSession`, etc.) acquire this lock with `-1` timeout, meaning **wait forever**. When a lock isn't released (due to browser issues, tab backgrounding, race conditions), every tab deadlocks.

### GitHub issues

- [#1594](https://github.com/supabase/supabase-js/issues/1594) - GoTrueClient uses infinite timeouts for lock acquisition causing deadlocks
- [#2013](https://github.com/supabase/supabase-js/issues/2013) - Supabase Auth-JS Deadlock Issue

## The Fix

### Strategy: Patch `navigator.locks.request()` globally

Instead of trying to configure Supabase's lock function (which `@nuxtjs/supabase` overrides), we **patch `navigator.locks.request()` itself** to add timeout support before Supabase even initializes.

### What the fix does

1. **Wraps `navigator.locks.request()`** with an `AbortController` that times out after 10 seconds
2. **On timeout**: Executes the auth operation without the lock (graceful degradation) instead of hanging forever
3. **Only patches Supabase locks** (identified by `sb-` or `auth-token` in the lock name) - doesn't affect other code
4. **Cross-tab coordinator**: Uses `BroadcastChannel` to broadcast lock timeout events to other tabs for observability

### Why this is safe

- The worst case of running without a lock is a redundant token refresh
- Supabase's server handles concurrent refresh attempts gracefully (returns the same session)
- Much better than the alternative: permanent deadlock requiring tab/browser restart

## Files

```
app/
├── plugins/
│   ├── 00.lock-fix.client.ts          # Core fix: patches navigator.locks with timeout
│   └── supabase-lock-fix.client.ts    # Cross-tab coordinator (BroadcastChannel)
├── utils/
│   └── supabase-lock.ts              # Lock utilities + diagnostics (queryLockState, forceReleaseLocks)
├── pages/
│   ├── index.vue                     # Home page with lock state display
│   ├── login.vue                     # Login page
│   └── diagnostics.vue               # Diagnostic page for debugging locks
└── app.vue
```

### Key file: `app/plugins/00.lock-fix.client.ts`

This is the core fix. It:

- Runs **before** all other plugins (the `00.` prefix ensures alphabetical ordering)
- Monkey-patches `navigator.locks.request()` to add `AbortController` timeout
- Only targets Supabase auth locks (checks for `sb-` or `auth-token` in lock name)
- Falls back to executing without lock on timeout (graceful degradation)

### Key file: `app/utils/supabase-lock.ts`

Provides diagnostic utilities:

- `queryLockState()` - Returns current held/pending locks (useful for debugging)
- `forceReleaseLocks()` - Steals stuck locks using `navigator.locks.request({ steal: true })`
- `timeoutLock()` - Standalone timeout lock function (can be used with custom Supabase clients)

## How to apply this fix to your own project

### Option 1: Copy the plugin (recommended for Nuxt + @nuxtjs/supabase)

1. Copy `app/plugins/00.lock-fix.client.ts` to your project's `plugins/` directory
2. That's it. The plugin patches `navigator.locks` globally before Supabase initializes.

### Option 2: Custom lock function (for vanilla Supabase JS)

If you're not using `@nuxtjs/supabase` and create the client yourself:

```typescript
import { createClient } from "@supabase/supabase-js";

// Option A: No-op lock (simplest, disables cross-tab coordination)
const noOpLock = async (
  name: string,
  acquireTimeout: number,
  fn: () => Promise<any>,
) => {
  return await fn();
};

// Option B: Timeout lock (recommended, preserves cross-tab coordination)
const timeoutLock = async (
  name: string,
  acquireTimeout: number,
  fn: () => Promise<any>,
) => {
  const timeout = acquireTimeout <= 0 ? 10000 : acquireTimeout;
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    return await navigator.locks.request(
      name,
      { signal: controller.signal },
      async () => {
        clearTimeout(timeoutId);
        return await fn();
      },
    );
  } catch (err: any) {
    clearTimeout(timeoutId);
    if (err.name === "AbortError") {
      console.warn(`Lock timeout for ${name}, proceeding without lock`);
      return await fn();
    }
    throw err;
  }
};

const supabase = createClient(url, key, {
  auth: {
    lock: timeoutLock, // or noOpLock for simplest fix
  },
});
```

### Option 3: React / Next.js / other frameworks

Copy the core logic from `00.lock-fix.client.ts` and run it early in your app initialization (before any Supabase client is created):

```typescript
// Run this BEFORE creating any Supabase client
if (typeof navigator !== "undefined" && navigator.locks?.request) {
  const original = navigator.locks.request.bind(navigator.locks);

  navigator.locks.request = function (...args: any[]): any {
    const name = args[0];
    if (!name?.includes("sb-") && !name?.includes("auth-token")) {
      return original(...args);
    }

    const [, optionsOrCallback, maybeCallback] = args;
    const options =
      typeof optionsOrCallback === "function" ? {} : optionsOrCallback || {};
    const callback =
      typeof optionsOrCallback === "function"
        ? optionsOrCallback
        : maybeCallback;

    if (options.signal || options.steal) return original(...args);

    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), 10000);

    return original(
      name,
      { ...options, signal: controller.signal },
      (lock: any) => {
        clearTimeout(timer);
        return callback(lock);
      },
    ).catch((err: any) => {
      clearTimeout(timer);
      if (err.name === "AbortError") return callback(null);
      throw err;
    });
  } as typeof navigator.locks.request;
}
```

## Diagnostics page

Navigate to `/diagnostics` to see:

- Current held and pending locks
- Lock timeout warnings from other tabs
- Stress test to verify the fix works
- Force-release button for stuck locks

## Configuration

The timeout is set to **10 seconds** by default in `00.lock-fix.client.ts`:

```typescript
const LOCK_TIMEOUT_MS = 10_000; // Adjust as needed
```

- **Lower values** (e.g., 5000ms): Faster recovery, but may trigger on slow networks
- **Higher values** (e.g., 30000ms): More tolerant of slow operations, but longer deadlock recovery

## Testing the fix

1. Deploy the app
2. Open 10+ tabs to the same page
3. Rapidly login/logout in one tab
4. Observe: other tabs should **not** break
5. Check console for `[lock-fix]` messages showing timeout recovery
6. Visit `/diagnostics` to see lock state in real-time
